package frc.robot.subsystems;
import frc.robot.RobotContainer;
import frc.robot.subsystems.Driver_Controller;
import edu.wpi.first.wpilibj.DriverStation;

public static boolean isDriving = false;
String alliance = "red";
public class NewAutoDrive{
    public static void driveToXYA(Double x, Double y, Double angle, Double speed){
        Driver_Controller.SwerveControlSet(true);
        Double odoAngle = ((RobotContainer.drivetrain.getState().Pose.getRotation().getDegrees()+ 360*1000 + 180)%360) - 180;
        //((RobotContainer.drivetrain.getPigeon2().getYaw().getValueAsDouble() + 360*1000 + 180)%360) - 180;
        Double odoy = RobotContainer.drivetrain.getState().Pose.getY();
        Double odox = RobotContainer.drivetrain.getState().Pose.getX();
        //Double speedMult = 10.0*((alliance == "red")?-1:1);
        speed *= ((alliance == "red")?1:-1);
        // use pythagorean theorum to calculate distance and if it is close enough
        Double dist = Math.pow(Math.pow((odox-x), 2) + Math.pow((odoy-y), 2), 0.5); 
        if (dist > 0.05){
            //Driver_Controller.SwerveCommandXValue = speedMult*(x - odox) * Math.cos(odoAngle);
            //Driver_Controller.SwerveCommandYValue = speedMult*(y - odoy) *  Math.sin(((Math.PI/2)) - odoAngle);
            Double driveAngle = Math.atan2(y - odoy, x - odox);
            Driver_Controller.SwerveCommandXValue = Intake.clamp(0.0, 1.0, dist*0.3+0.15)*-speed*Math.cos(driveAngle);
            Driver_Controller.SwerveCommandYValue = Intake.clamp(0.0, 1.0, dist*0.3+0.15)*-speed*Math.sin(driveAngle);
        }else{
            Driver_Controller.SwerveCommandXValue = 0.0;
            Driver_Controller.SwerveCommandYValue = 0.0;
        }
        Driver_Controller.SwerveCommandEncoderValue = odoAngle*0 + angle;// + ((alliance == "red")?180:0);
    }
    public static double scoringAngles[] = {0, 0, -60, -60, -120, -120, -180, -180, -240, -240, -300, -300};
    public static double scoringPosRed[12][2], scoringPosBlue[12][2];
    public static double reefY = 4.025908052, reefXBlue = (5.321056642+3.657607315)/2.0, reefXRed = (13.89052578+12.22733045)/2.0;
    public static double reefAltitude = Math.abs(3.657607315-reefXBlue);
    public static double pillarOffset = 0.165, robotOffsetLeft = 0.249, robotOffsetBack = 0.435;
    public static double desiredPosition = {0, 0, 0, 0};
    public static String lastLocation = "";
    public static double algaeRemoveRed[][] = { 
        {14.32552578, 3.725908052},
        {13.43216533, 2.779603562},
        {12.16607567, 3.079603562},
        {11.79233045, 4.325908052},
        {12.68569091, 5.272212542},
        {13.95178057, 4.972212542},  
    };
    public static double algaeRemoveBlue[][] = { 
        {3.222861316, 4.325908052},
        {4.116221769, 5.272212542},
        {5.382311431, 4.972212542},
        {5.756056642, 3.725908052},
        {4.862696189, 2.779603562},
        {3.596606527, 3.079603562},  
    };

    public static void setupAutoDrive(){
        if(DriverStation.getAlliance().toString().charAt(9) == 'B'){   
            alliance = "blue";  // blue
        }
        for (int i = 0; i < 12; ++i){
            double mult1 = Math.sin(math.toRadians(scoringAngles[i])), mult2 = Math.cos(math.toRadians(scoringAngles[i]));
            scoringPosBlue[i] = {(robotOffsetBack+reefAltitude)*mult2 + (robotOffsetLeft*((i%2 == 0)?1:-1)-pillarOffset)*multi1, (robotOffsetBack+reefAltitude)*mult1 + (robotOffsetLeft*((i%2 == 0)?1:-1)-pillarOffset)*multi2}; 
        }
        for (int i = 0; i < 12; ++i){
            scoringPosRed[i] = {scoringPosBlue[(i+6)%12][0]+8.569469139, scoringPosBlue[(i+6)%12][1]};
        }
    }
    public static void periodicDriveToLocation(boolean willDrive, String Location, int position){
        if ((!isDriving && willDrive) || (lastLocation != Location)){
            switch(Location){
                case "reef":
                    desiredPosition = {((alliance == "blue")?scoringPosBlue:scoringPosRed)[position][0]+Math.sin(math.toRadians(scoringAngles[i])),
                    ((alliance == "blue")?scoringPosBlue:scoringPosRed)[position][1]+Math.cos(math.toRadians(scoringAngles[i])),
                    scoringAngles[position], 2.0};
                    break;
                case "hps":
                    if (alliance == "blue"){
                        if (RobotContainer.drivetrain.getState().Pose.getY() > reefY)
                        desiredPosition = {1.18, 6.95, 306.0+180, 2.0};
                        else desiredPosition = {1.18, 1.11, 54.0+180, 2.0};
                    }else{
                        if (RobotContainer.drivetrain.getState().Pose.getY() > reefY)
                        desiredPosition = {16.37, 6.95, 234.0+180, 2.0};
                        else desiredPosition = {16.35, 1.13, 126.0+180, 2.0};
                    }
                    break;
                case "orient":
                    desiredPosition = {RobotContainer.drivetrain.getState().Pose.getX()-RobotContainer.betterJoystickCurve(Driver_Controller.m_Controller0.getLeftX(), Driver_Controller.m_Controller0.getLeftY())[0],
                    RobotContainer.drivetrain.getState().Pose.getY()-RobotContainer.betterJoystickCurve(Driver_Controller.m_Controller0.getLeftX(), Driver_Controller.m_Controller0.getLeftY())[1],
                    AutoDriveFinal.scoringAngles[position]+((alliance == "blue")?180:0),
                    1.5};
                    break;
                case "remove":
                    desiredPosition = {(alliance == "blue")?algaeRemoveBlue[position/2][0]:algaeRemoveRed[position/2][0],
                    (alliance == "blue")?algaeRemoveBlue[position/2][1]:algaeRemoveRed[position/2][1],
                    scoringAngles[position]+((alliance == "blue")?180:0),
                    2.0};
                    break;
            }
        }
        if (willDrive)driveToXYA(desiredPosition[0], desiredPosition[1], desiredPosition[2], desiredPosition[3]);
        isDriving = willDrive;
        lastLocation = location;
        Driver_Controller.SwerveControlSet(willDrive);
    }

    
}